import { ComputedRef } from 'vue'
import { MaybeRefOrGetter } from './types.uts'
import { UseTimeoutFnReturn, useTimeoutFn } from './useTimeoutFn.uts'

/**
 * useTimeout 配置项
 */
export type UseTimeoutOptions = {
  /**
   * 超时后的回调函数
   */
  callback?: (args : any[]) => void

  /**
   * 继承自 UseTimeoutFnOptions
   */
  immediate?: boolean
  immediateCallback?: boolean
}

/**
 * useTimeout 返回值接口
 * 为了兼容 controls 模式，我们统一返回一个包含 ready 的对象
 */
export interface UseTimeoutReturn extends UseTimeoutFnReturn {
  /** * 是否已到达超时时间 */
  ready : ComputedRef<boolean>
}

/**
 * 在给定时间后更新状态。
 * ### 注意事项
 * - **不支持解构**：必须通过 `const timeout = useTimeout()` 后使用 `timeout.ready` 访问。
 * - **返回值说明**：在 UTS 中为了类型稳定，统一返回包含 controls 的对象，不再根据布尔值切换返回类型。
 *
 * @example
 * ```
 * // 1. 基本用法
 * const timeout = useTimeout(2000)
 * // <view v-if="timeout.ready.value">时间到</view>
 * // 2. 带回调和控制
 * const timeout = useTimeout(1000, {
 * callback: (args : any[]) => { console.log('Timeout!') }
 * })
 * timeout.stop()
 * ```
 * @param interval 延迟时间 (ms)
 * @param options 配置项
 */
export function useTimeout(
  interval : MaybeRefOrGetter<number> | null = 1000,
  options : UseTimeoutOptions | null = null
) : UseTimeoutReturn {
  const optionsSafe = options ?? ({} as UseTimeoutOptions)

  const cb = optionsSafe.callback ?? ((_args : any[]) => {})

  const controls = useTimeoutFn(
    cb,
    interval,
    optionsSafe
  )

  return new UseTimeoutReturnImpl(controls)
}

/**
 * UseTimeout 实现类
 * 通过组合 (Composition) 的方式包装 useTimeoutFn 的实例
 */
class UseTimeoutReturnImpl implements UseTimeoutReturn {
  private _controls : UseTimeoutFnReturn

  /**
   * 是否已就绪（即计时结束）
   */
  ready : ComputedRef<boolean>

  constructor(controls : UseTimeoutFnReturn) {
    this._controls = controls
    this.ready = computed(() : boolean => !this._controls.isPending.value)
  }

  // 代理 isPending 状态
  get isPending() : ComputedRef<boolean> {
    return this._controls.isPending
  }

  /**
   * 停止计时
   */
  stop() {
    this._controls.stop()
  }

  // #ifdef APP
  override start() {
    this._controls.start()
  }

  override start(...args : any[]) {
    this._controls.start(args)
  }
  // #endif

  // #ifndef APP
  start(...args : any[]) {
    this._controls.start(args)
  }
  // #endif
}
